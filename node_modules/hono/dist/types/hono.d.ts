import type { ExecutionContext } from './context';
import type { Router } from './router';
import type { Env, ErrorHandler, H, HandlerInterface, MiddlewareHandlerInterface, NotFoundHandler, OnHandlerInterface, MergeSchemaPath, RemoveBlankRecord } from './types';
interface RouterRoute {
    path: string;
    method: string;
    handler: H;
}
declare const Hono_base: new <E_1 extends Env = Env, S_1 = {}>() => {
    all: HandlerInterface<E_1, "all", S_1>;
    get: HandlerInterface<E_1, "get", S_1>;
    post: HandlerInterface<E_1, "post", S_1>;
    put: HandlerInterface<E_1, "put", S_1>;
    delete: HandlerInterface<E_1, "delete", S_1>;
    head: HandlerInterface<E_1, "head", S_1>;
    options: HandlerInterface<E_1, "options", S_1>;
    patch: HandlerInterface<E_1, "patch", S_1>;
} & {
    on: OnHandlerInterface<E_1, S_1>;
} & {
    use: MiddlewareHandlerInterface<E_1, S_1>;
};
export declare class Hono<E extends Env = Env, S = {}> extends Hono_base<E, S> {
    readonly router: Router<H>;
    readonly strict: boolean;
    private _tempPath;
    private path;
    routes: RouterRoute[];
    constructor(init?: Partial<Pick<Hono, 'router' | 'strict'>>);
    private notFoundHandler;
    private errorHandler;
    route<SubPath extends string, SubEnv extends Env, SubSchema>(path: SubPath, app?: Hono<SubEnv, SubSchema>): Hono<E, RemoveBlankRecord<MergeSchemaPath<SubSchema, SubPath> | S>>;
    onError(handler: ErrorHandler<E>): this;
    notFound(handler: NotFoundHandler<E>): this;
    showRoutes(): void;
    private addRoute;
    private matchRoute;
    private handleError;
    private dispatch;
    handleEvent: (event: FetchEvent) => Response | Promise<Response>;
    fetch: (request: Request, Env?: E['Bindings'] | {}, executionCtx?: ExecutionContext) => Response | Promise<Response>;
    request: (input: Request | string, requestInit?: RequestInit) => Promise<Response>;
}
export {};
